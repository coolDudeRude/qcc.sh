#!/bin/bash
#==============================================================================
# A simple implementation of Xonotic's qcc.sh tool see:
# https://gitlab.com/xonotic/xonotic-data.pk3dir/-/blob/master/qcsrc/tools/qcc.sh
#
# The general idea is to use GCC's preprocessor for all the fancy macro and other
# features and any QuakeC compiler as the compilation backend.
#==============================================================================

#===========================
# Temp Dir Setup
#===========================
# setup temporary directory to store intemediate files
# which will be removed once compilation is done.
# If for some reason cannot create a temp dir exit.
TEMPDIR=$(mktemp -d) || exit 1
# Remove the temp dir on exit or on Ctrl-C
trap '{ rm -rf -- "$TEMPDIR"; }' EXIT

#===========================
# Helper Functions
#===========================

## Error
# Print the error message and exit.
#
# Usage: error <string>
error() {
    echo -e "qcc.sh:error $1"
    exit 1
}

## Remove GCC's Pragmas
# Removes GCC's pragmas from the file generated by the
# GCC's preprocessor. It contains junk that GMQCC or any
# other QC compiler might not recognize.
# Taken from:
# https://gitlab.com/xonotic/xonotic-data.pk3dir/-/blob/master/qcsrc/tools/qcc.sh#L133
#
# Usage: remove_gcc_pragmas <filepath>
remove_gcc_pragmas() {
    sed -E 's/^#(line)? ([[:digit:]]+) "(.*)".*/'$'\\\n''#pragma file(\3)'$'\\\n''#pragma line(\2)/g' "$1"
}

## Preprocessor Frontend
# Passes the QC Source through the GCC's preprocessor
# and generates a source structure that's recognized by
# GMQCC.
#
# Usage: preprocessor <filepath>
preprocessor() {
    # ppi.qc
    # ppi = PreProcessor Intermediate file
    ${CC} ${CFLAGS} $1 -o $TEMPDIR/ppi.qc

    # if GCC encountered an error during processing
    # exit script execution.
    if [[ $? != 0 ]]; then
        error "preprocessor (GCC) exited with an error."
    fi
    # fppi.qc
    # fppi = Filtered PreProcessor Intermediate file
    remove_gcc_pragmas $TEMPDIR/ppi.qc > $TEMPDIR/fppi.qc
}

## Compilation Backend
# Using the compiler specified with `QCC` env var
# the QC source is compiled into progs.dat
#
# Usage: compile <filepath> <outputpath>
compile() {
    ${QCC} ${QCFLAGS} $1 -o $2
}

## QCC
# Function acting as the entry point for the psudo compiler.
#
# Usage: qcc <qcfilepath> <outpath>
qcc() {
    preprocessor $1
    compile $TEMPDIR/fppi.qc $2
}

## Usage message
message_help() {
    echo "Usage:"
    echo "  qcc.sh INPUT [OUTPUT]"
}

#==================================
# Main interface
#==================================

# CC & QCC setup
# Use the environment variable if they exits
# otherwise use default except for QCC which
# should be defined.
if [[ -z $CC ]]; then
    CC=cc
fi

if [[ -z $CFLAGS ]]; then
    CFLAGS="-xc -E -I."
fi

if [[ -z $QCC ]]; then
    error "QCC env variable not set."
fi

if [[ -z $QCFLAGS ]]; then
    QCFLAGS="-std=gmqcc -Wall"
fi

# TODO: positional argument parsing.
INPUTFILE=$1
OUTPUTFILE=$2

# No inputfile is provided.
if [[ -z $INPUTFILE ]]; then
    message_help
    exit 1
fi

# if no output file was given use the default
# which is progs.dat in the current directory.
if [[ -z $OUTPUTFILE ]]; then
    OUTPUTFILE=./progs.dat
fi

## proceed with compilation
if [[ -e $INPUTFILE ]]; then
    qcc $INPUTFILE $OUTPUTFILE
else
    error "${INPUTFILE} no such file exists."
fi

